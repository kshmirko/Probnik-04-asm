.ifndef __TWI__
.define __TWI__

; Работа с TWI

.equ    START           =   0x08
.equ    RSTART          =   0x10
.equ    SLA_W_ACK       =   0x18
.equ    SLA_W_NACK      =   0x20
.equ    DATA_ACK        =   0x28
.equ    DATA_NACK       =   0x30
.equ    SLA_W_LOST      =   0x38

;======= Стартовая посылка по шине i2c ======================================

i2c_start:
	push    r16					
    ldi     r16,(1<<TWINT)|(1<<TWSTA)|(1<<TWEN)  ; Выполняем посылку стартовой комбинации
    out     TWCR,r16      ; Посылаем полученный байт в TWCR
    rcall   i2c_wait      ; Ожидание формирования start в блоке TWI
    pop     r16           ; Возвращаем данные в r16 из стека
	ret
 
;======= Стоповая посылка по шине i2c ======================================
i2c_stop:
    push    r16					
    ldi     r16,(1<<TWINT)|(1<<TWSTO)|(1<<TWEN)  ; Отправляем стоповую посылку
    out     TWCR,r16      ; Посылаем полученный байт в TWCR
    pop     r16           ; Возвращаем данные в r16 из стека
    ret
 
;======= Посылка байта информации по шине i2c ==============================
i2c_send:
    push    r16					
    out     TWDR,r16      ; Записываем передаваемый байт в регистр TWDR
    ldi     r16,(1<<TWINT)|(1<<TWEN)  ; Формируем байт, отвечающий 
                                      ; за пересылку информационного байта
    out     TWCR,r16      ; Посылаем полученный байт в TWCR
    rcall   i2c_wait      ; Ожидание окончания пересылки байта
    pop     r16           ; Возвращаем данные в r16 из стека
    ret
 
;======= Приём информационного байта по шине i2c ===========================
i2c_receive:
; Принятый байт помещается в регистр r16, поэтому рекомендуется	
; продумать программу так, чтобы в этот момент в нём не было 
; важной информации, байт не сохраняется в стеке в коде данной 
; процедуры
    ldi     r16,(1<<TWINT)|(1<<TWEN)|(1<<TWEA)  ; Формируем байт, отвечающий за прием 
    out     TWCR,r16      ; Посылаем полученный байт в TWCR
    rcall   i2c_wait      ; Ожидание окончания приёма байта
    in      r16,TWDR      ; Считываем полученную информацию из TWDR
    ret

;======= Приём последнего байта (NACK) =====================================
i2c_receive_last:
; Принятый байт помещается в регистр r16, поэтому рекомендуется	
; продумать программу так, чтобы в этот момент в нём не было 
; важной информации, байт не сохраняется в стеке в коде данной 
; процедуры
    ldi     r16,(1<<TWINT)|(1<<TWEN) ; Формируем байт, отвечающий за прием информационного байта
    out	    TWCR,r16      ; Посылаем полученный байт в TWCR
    rcall   i2c_wait      ; Ожидание окончания приёма байта
    in      r16,TWDR      ; Считываем полученную информацию из TWDR
    ret

;======= Ожидание готовности TWI ===========================================
i2c_wait:
    in      r16,TWCR      ; Загружаем значение из TWCR в r16
    sbrs    r16,TWINT     ; Функция ожидания выполняется до тех пор, пока поднят флаг 
                          ; прерывания в 1
    rjmp    i2c_wait
    ret

;===========================================================================
.endif

