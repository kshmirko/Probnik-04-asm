.ifndef __TWI__
.define __TWI__

; Работа с TWI

.equ    START           =   $08
.equ    RSTART          =   $10
.equ    SLA_W_ACK       =   $18
.equ    SLA_W_NACK      =   $20
.equ    DATA_ACK        =   $28
.equ    DATA_NACK       =   $30
.equ    SLA_W_LOST      =   $38

;======= Стартовая посылка по шине i2c ======================================
; посылает стартовую последовательность на линию
; изменяет и не восстанавливает регистр R16
i2c_start:
    push r16
	ldi     r16,(1<<TWINT)|(1<<TWSTA)|(1<<TWEN)  ; Выполняем посылку 
                                                 ; стартовой комбинации
    out     TWCR,r16      ; Посылаем полученный байт в TWCR
    rcall   i2c_wait      ; Ожидание формирования start в блоке TWI
    pop r16
	ret
 
;======= Стоповая посылка по шине i2c ======================================
i2c_stop:
    push r16
    ldi     r16,(1<<TWINT)|(1<<TWSTO)|(1<<TWEN)  ; Отправляем стоповую посылку
    out     TWCR,r16      ; Посылаем полученный байт в TWCR
    pop r16
    ret
 
;======= Посылка байта информации по шине i2c ==============================
i2c_send:
    push r16
    out     TWDR,r16      ; Записываем передаваемый байт в регистр TWDR
    ldi     r16,(1<<TWINT)|(1<<TWEN)  ; Формируем байт, отвечающий 
                                      ; за пересылку информационного байта
    out     TWCR,r16      ; Посылаем полученный байт в TWCR
    rcall   i2c_wait      ; Ожидание окончания пересылки байта
    pop r16
    ret
 
;======= Приём информационного байта по шине i2c ===========================
i2c_receive:
; Принятый байт помещается в регистр r16, поэтому рекомендуется	
; продумать программу так, чтобы в этот момент в нём не было 
; важной информации, байт не сохраняется в стеке в коде данной 
; процедуры
    ldi     r16,(1<<TWINT)|(1<<TWEN)|(1<<TWEA)  ; Формируем байт, отвечающий за прием 
    out     TWCR,r16      ; Посылаем полученный байт в TWCR
    rcall   i2c_wait      ; Ожидание окончания приёма байта
    in      r16,TWDR      ; Считываем полученную информацию из TWDR
    ret

;======= Приём последнего байта (NACK) =====================================
i2c_receive_last:
; Принятый байт помещается в регистр r16, поэтому рекомендуется	
; продумать программу так, чтобы в этот момент в нём не было 
; важной информации, байт не сохраняется в стеке в коде данной 
; процедуры
    ldi     r16,(1<<TWINT)|(1<<TWEN) ; Формируем байт, отвечающий за прием информационного байта
    out	    TWCR,r16      ; Посылаем полученный байт в TWCR
    rcall   i2c_wait      ; Ожидание окончания приёма байта
    in      r16,TWDR      ; Считываем полученную информацию из TWDR
    ret

;======= Ожидание готовности TWI ===========================================
i2c_wait:
    in      r16,TWCR      ; Загружаем значение из TWCR в r16
    sbrs    r16,TWINT     ; Функция ожидания выполняется до тех пор, пока поднят флаг 
                          ; прерывания в 1
    rjmp    i2c_wait
    ret

;===========================================================================
.endif

